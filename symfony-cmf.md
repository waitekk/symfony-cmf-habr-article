## Вместо предисловия
Я программирую Yii уже два года и в последнее время начал засматриваться на Symfony Framework 2. Отчасти меня привлекает продуманная архитектура, отчасти слабая связность компонентов, отчасти гибкость построенных приложений. Сразу после того, как я разобрался с основным устройством нового фреймворка, мне стало интересно, возможно ли на нем построить CMS, а может быть, даже воспользоваться готовой.

Коробочного решения пока не придумали, однако, каким-то образом я забрел на сайт проекта Symfony CMF и оказался сражен наповал методичным подходом к решению тех проблем, с которыми я сталкивался в бытность работы на конвеере по натягиванию дизайна на какой-нибудь Друпал. На Хабре публикаций по именно CMF нет, да и сам проект еще очень сырой, однако в перспективе выглядит все интересно, хоть местами и есть к чему придраться.

## Зачем еще один CMF?
Не секрет, что на рынке существует достаточно много готовых продуктов, как платных (1С-Битрикс, UMI), так и бесплатных (Drupal, MODx, Wordpress, Joomla). Поэтому вполне логично, что при виде надписи *Whatever CMS/CMF* может возникнуть вопрос **Зачем вообще делать еще одну CMS? Их же и так полно.**
И я абсолютно согласен. Как пользователь.

CMS действительно пруд-пруди. Но как разработчик, я часто проливал пот, кровь и слезы, пытаясь добиться от них чего-то большего, чего-то не заложенного авторами базовой системы и сторонних расширений.

Из-за недостаточно продуманной архитектуры, при работе с готовыми решениями приходится сталкиваться с:
* отсутствием внятного разделения логики, конфигурации, содержимого и представления. Достаточно вспомнить модули Drupal — куча файлов, мешанина из непонятно как названных глобальных функций, хуков и прочего. Вот кстати [неплохая статья](http://odino.org/why-we-choose-symfony2-over-any-other-php-framework/), в которой этот вопрос обсуждается
* много легаси-кода, остающегося со старых версий. Периодически разработчиками предпринимаются попытки исправить это, обещаются переписывания ядра и прочие радости, но пока новая (переписанная) версия дойдет до стадии «можно пользоваться», времени может пройти очень много
* часто в системе отсуствуют такие понятия как development, testing, и отсутствуют инструментария для деплоя
* проблемы с кэшированием. Где-то его нет, где-то оно есть, но не дает достаточную степень гибкости, или есть проблемы с инвалидацией, или просто он не спасает и т. д.
* низкая производительность на больших (в данном случае это понятие относительное) объемах данных
* сложность в создании своих компонентов или переопределении существующих
* приходится выбирать между заранее определенными типами данных, либо довольствоваться EAV-хранилищами поверх реляционных СУБД, либо еще что похуже
* неудобные шаблонизаторы-велосипеды, придуманные авторами CMS ...
* ... и все это как следствие синдрома ([NIH](http://en.wikipedia.org/wiki/Not_invented_here)).

Разработчики этих систем в курсе недостатков и не отвергают предъявленных обвинений, однако в момент решить все эти проблемы, само собой, невозможно. Впрочем, не будем ругаться на все подряд. Начать хотелось бы с того, как идеальная CMS должна хранить данные.

## Проблема хранения данных
Информация, которую пользователи забивают в CMS редко бывает идеально структурированной. Порой бывает нужно добавить одно, другое, третье, десятое поле. Каждый раз менять схему? А если записей слишком много?

«NoSQL!», — радостно крикнет небольшая кучка хипстеров.

Но позвольте. Отсутствие структуры не значит отсутствие организации. Как бы там ни было, чаще всего данные на сайты связаны в виде некого дерева или даже нескольких деревьев. «Добро пожаловать в мир графовых баз данных!», — раздастся сквозь бороду крик из дальнего угла комнаты.

А ведь еще по-хорошему было бы неплохо хранить ревизии контента.

А еще хочется поиск сразу.

А еще все это надо быстро, без головной боли. И всегда быть готовым к масштабированию.

### Content Repository
Становится ясно, что одним мускулом не отделаешься. Реализовать в плоских базах данных структуру графа, да еще с версионностью и прочими плюшками очень сложно и вообще-то не нужно.

Ведь придумали хранилища содержимого, или репозитории контента, если транслитеровать буржуйский. Репозитории призваны давать доступ к записи, чтению и поиску данных независимо от приложений, которым эти данные нужны. По сути это хранилище данных с акцентом прежде всего на логический аспект обработки данных.

### JCR-170
Проблема хранения данных для документо-ориентированных систем возникла уже давно, поэтому еще в первой половине двухтысячных люди из компании Day Software (а именно — David Nüscheler) подали через Java Community Process запрос на принятие спецификации [Content Repository API for Java (JCR)](http://www.jcp.org/en/jsr/detail?id=170), которой был присвоен порядковый номер 170. Позднее спецификация проходила под номером JSR-283 (вторая версия), но до сих пор чаще встречается ссылка именно на первый вариант.

Согласно спецификации, репозиторий является объектной базой данных, которая обеспечивает хранение, поиск и получение иерархических данных. Кроме того, предоставляемый API позволяет использовать версионность данных, транзакции, отслеживание изменений, импорт/экспорт в XML, а еще хранить двоичные и метаданные.

Такой репозиторий организован в виде дерева узлов, которые имеют свойства. Непосредственно данные хранятся именно в них, причем это могут быть и числа, и строки, и двоичные данные произвольной длины. Узлы могут подразделяться на типы, иметь дочерние узлы, определенные поведенческие характеристики или просто ссылаться на другие узлы (при помощи специального свойства и уникального идентификатора, который имеет каждый узел).

Начиная со второй версии спецификации, хранилище должно уметь отзываться на SQL-запросы, что удобней, чем их XPath-собратья из первой редакции.

Как яркий пример реализации подобного счастья можно выделить проект [Apache Jackrabbit](http://jackrabbit.apache.org/), опенсорс-репозиторий, написанный на Java. Помимо всех вышеописанных вкусностей, этот проект (начатый еще в 2004 году как начальная реализация JCR API) умеет гибко контролировать доступ к контенту. Еще там есть кластеринг, механизмы блокировок и прочее, но нам сейчас это не очень интересно, поэтому пропустим.

### PHPCR
Но ведь не все пишут на Java! (Опустим шуточки на эту тему)
Для таких, как мы, был создан [PHPCR](http://phpcr.github.com/) — JCR API, адатированный под PHP. Исходя из того, что API специфицирован, следует: можно написать приложение один раз, а потом просто менять бэкенды (теоретически, конечно).
Важный плюс — мы не изобретаем велосипед (ведь как мы помним, проблема хранения данных в CMS уже решена).
Конечно, такая инициатива не могла остаться без внимания — Дэвид [отправил запрос](https://java.net/jira/browse/JSR_333-28) на принятие PHPCR в JCR 2.1. Очень мило.

Однако, вернемся к манящей мысли о разных бэкендах.

Имеем мы на текущий момент не так много реализаций, но и эти уже интересные:
* [Jackalope](https://github.com/jackalope/jackalope)
  * поддерживает Jackrabbit
  * поддерживает Doctrine DBAL (хранение данных поверх реляционных БД)
* [Midgard2 PHPCR](http://midgard-project.org/phpcr/)

Эти реализации предоставляют возможность не только общаться через API с Jackrabbit, но и хранить деревья в RDBMS (MySQL, PostgreSQL, SQLite и другие).

На текущий момент PHPCR поддерживает следующие функции:
* доступ к дереву
* доступ к узлам по UUID
* поиск по узлам
* версионность
* определение возможностей
* Импорт и экспорт в XML
* Блокировки
* Транзакции*
* Разрешения
* Контроль доступа*
* Отслеживание изменений

(*) — Еще не реализовано в Jackalope-Jackrabbit, хотя информация могла немного устареть.

Ключевые концепции PHPCR:
* все содержимое хранится в дереве узлов
* у узлов есть имя и тип
* у узлов есть дочерные узлы и свойства, хранящие значения
* значения свойств могут хранить числа, строки, двоичные объекты и ссылки на другие узлы

Где-то мы уже это слышали, не правда ли?

Посмотрим, как может выглядеть такой репозиторий (схематично, конечно):
```xml
<jcr:root>
  <cms>
    <pages>
      <home title="Hello">
        <block title="News"
          content="Today: PHPCR presentation"/>
      </home>
      <contact title="Contact"
        content="phpcr-users@groups.google.com"/>
    </pages>
  </cms>
</jcr:root>
```
Ничего сверхъестественного (пока).
Рассмотрим чуть подробнее, с чем придется работать.

#### Узлы
* узел — именованный контейнер, у которого всегда есть родитель
* напоминает XML-элементы
* узлы можно создавать, удалять, модифицировать, копировать
* _путь_ к узлу состоит из пути родительского узла и имени текущего узла:
  * Путь: /cms/pages/home
  * Родительский путь: /cms/pages
  * Имя узла: home

#### Свойства узлов
* у узлов есть именованные свойства, хранящие значения
* напоминают XML-атрибуты
* типы данных: STRING, URI, BOOLEAN, LONG, DOUBLE, DECIMAL, BINARY, DATE, NAME, PATH, WEAKREFERENCE, REFERENCE
* типы (WEAK)REFERENCE создают ссылки на другие узлы
* узлы и свойства могут иметь пространства имен: ```jcr:created```, ```jcr:mimeType```, ```phpcr:class```

#### Основные типы узлов
* определяют разрешенные для использования имена, а также типы свойств и дочерних узлов
* у каждого узла должен быть установлен основной тип
* для хранения-чего-угодно используется ```nt:unstructured```
* среди прочих встроенных типов есть nt:address, nt:folder, nt:file и другие
* для создания своей схемы можно определять новые типы узлов

#### Mixin-типы узлов
* у основных типов нет множественного наследования
* но есть миксин-типы, которые добавляют узлам [trait](https://en.wikipedia.org/wiki/Trait_(computer_programming\))-подобную функциональность
* миксин-типы могут быть назначены узлу во время его жизни

Пример:
Допустим, у нас есть свойство ```jcr:uuid```, в котором хранится уникальный идентификатор. Зная uuid, мы можем создать миксин ```mix:referenceable```, а на его основе ```mix:versionable``` (но тогда нам еще потребуется иметь свойства ```jcr:versionHistory```, ```jcr:predecessors```, ```jcr:baseVersion```, ```jcr:isCheckedOut```, ```jcr:mergeFailed``` и т. д.)

#### Рабочие пространства
* рабочих пространств может быть несколько, каждое хранит в себе свое дерево узлов
* напоминает файловую систему Unix и ветки в Git/SVN, каждую можно клонировать и выполнять слияния
* могут использоваться независимо

![Процесс получения данных в PHPCR](http://habrastorage.org/storage2/6bc/f46/d7a/6bcf46d7ae14540b2cc40e014849ef83.png "Процесс получения данных в PHPCR")

А теперь немного примеров того, как со всеми этим работать:

Создание сессии
```php
use PHPCR\SimpleCredentials;

// конфигурация, зависимая от конкретной реализации бэкенда
use Jackalope\RepositoryFactoryJackrabbit as Factory;
$parameters = array(
    'jackalope.jackrabbit_uri'
        => 'http://localhost:8080/server',
);
$repository = Factory::getRepository($parameters);

// а вот дальше все стандартно для любых реализаций
$creds = new SimpleCredentials('admin','admin');
$session = $repository->login($creds, 'default');
```

CRUD-операции
```php
$root = $session->getRootNode();

// узлы всегда добавляются как дочерние для существующих
$node = $root->addNode('test', 'nt:unstructured');

// новый узел сразу доступен в текущей сессии
$node = $session->getNode('/test');

// создать/обновить свойство
$node->setProperty('prop', 'value');

// теперь узел доступен для всех сессий
$session->save();

// удалить узел и все дочерние узлы
$node->remove();

// выдаст ошибку, если узел кто-то редактировал в другой сессии
$session->save();
```

Обход дерева
```php
$node = $session->getNode('/site/content');

foreach ($node->getNodes() as $child) {
    var_dump($child-?getName());
}

// или короче
foreach ($node as $child) {
    var_dump($child->getName());
}

// фильтр по имени
foreach ($node->getNodes('di*') as $child) {
    var_dump($child->getName());
}
```

Версионность
```php
// включаем версионность
$node = $session->getNode('/site/content/about');
$node->addMixin('mix:versionable');
$session->save();
// создаем начальную версию
$node->setProperty('title', 'About');
$session->save();

// чек-ин (создаем версию)
// и чек-аут (подготовка к дальнейшим обновлениям)
// результат этих операций доступен сразу же без вызова $session->save()
$vm = $session->getWorkspace()->getVersionManager();
$vm->checkpoint($node->getPath());

// обновляем узел
$node->setProperty('title', 'Ups');
$session->save();

// создаем еще одну версию, оставляем в состоянии «только для чтения»
$vm->checkin($node->getPath());

$base = $vm->getBaseVersion($node->getPath());
$current = $base->getLinearPredecessor();
$previous = $current->getLinearPredecessor();

// берем слепок старой версии
$frozenNode = $previous->getFrozenNode();
echo $frozenNode->getProperty('title'); // About

// восстанавливаем живые данные из текущей версии
$vm->restore(true, $previous);

$node = $session->getNode('/site/content/about');
echo $node->getProperty('title'); // About
```

Поиск
```php
$qm = $workspace->getQueryManager();

// в SQL2 оператор звездочки "*" не возвращает все столбцы
// а по крайней мере путь и степень соответствия
// (см. http://docs.jboss.org/exojcr/1.12.13-GA/developer/en-US/html/ch-jcr-query-usecases.html#d0e3332)
$sql = "SELECT * FROM [nt:unstructured]
    WHERE [nt:unstructured].type = 'nav'
    AND ISDESCENDANTNODE('/some/path')
    ORDER BY score, [nt:unstructured].title";
$query = $qm->createQuery($sql, 'JCR-SQL2');
$query->setLimit($limit);
$query->setOffset($offset);
$queryResult = $query->execute();

foreach ($queryResult->getNodes() as $node) {
    var_dump($node->getPath());
}
```
Другие примеры кода можно посмотреть [в этой презентации](http://phpcr.github.io/slides.html#20).

#### Резюме по PHPCR
Итак, у нас есть адаптированный API для доступа к репозиториям контента, отвечающим стандарту JCR API.

Пока что должно возникнуть два главных вопроса, и на оба будет дан ответ:

**Когда использовать PHPCR?**
* Когда нужно работать с иерархическими навигационными структурами
* Когда у вас есть данные, связанные друг с другом
* Когда нужна версионность данных

**Когда НЕ использовать PHPCR?**
Для строго структурированного контента и использования аггрегирующих запросов рекомендуется использовать реляционные базы данных. Например, в интернет-магазине описания товаров можно хранить в PHPCR, а заказы — в РСУБД.

### PHPCR ODM
Спецификация это здорово, но API слишком абстрактный и неудобен для повседневного использования (ведь большинство привыкло к какой-нибудь ORM-системе). И тут на сцену выходит проект [PHPCR ODM](http://www.doctrine-project.org/projects/phpcr_odm), который представляет собой связку PHPCR и Doctrine object-document mapper. [Doctrine ORM](http://www.doctrine-project.org/projects/orm.html), знакомая разработчикам, использующим SF2 (да и не только SF2), реализует паттерн [Data mapper](http://en.wikipedia.org/wiki/Data_mapper_pattern) для доступа к данным, хранящимся в RDMBS.
ODM, подобно Doctrine ORM использует Data mapper для полного отделения бизнес-логики от слоя хранения данных, которым в данном случае является репозиторий контента. ODM сохраняет объекты в виде PHPCR-узлов, называя их документами. При этом, поскольку PHPCR уже независим от реализаций, не требует писать новый слой абстракции от базы данных (DBAL).

Что же такое **документ** в терминологии PHPCR ODM?

Документом является лаконичный PHP-класс, не реализующий какие-либо интерфейсы (верней, реализовать-то всегда можно, но сама библиотека этого не требует) и не унаследованный от каких-то базовых абстрактных классов. Такая сущность не должна иметь в себе методы с ключевым словом ```final```, реализовывать методы ```clone``` и ```wakeup```, или реализовывать, но делая это *очень осторожно*. Сама по себе сущность состоит из свойств, фиксируемых в хранилище. Поскольку ODM работает поверх библиотеки [Doctrine Common](http://www.doctrine-project.org/projects/common.html), реализующей базовый функционал (аннотации, кэширование и автозагрузка классов), маппинг свойств в хранилище данных к свойствам класса производится знакомым всем путем — через аннотации в PHP-комментариях, либо YAML/XML-конфигах. У каждого документа есть заголовок (title) и содержимое (content). Все документы организованы в виде дерева и могут ссылаться на другие документы. Взгляните на пример документа:

```php
namespace Demo;

use Doctrine\ODM\PHPCR\Mapping\Annotations as PHPCRODM;

/**
 * @PHPCRODM\Document
 */
class MyDocument
{
    /**
     * @PHPCRODM\Id
     */
    private $id;
    /**
     * @PHPCRODM\ParentDocument
     */
    private $parent;
    /**
     * @PHPCRODM\Nodename
     */
    private $name;
    /**
     * @PHPCRODM\Children
     */
    private $children;
    /**
     * @PHPCRODM\String
     */
    private $title;

    /**
     * @PHPCRODM\String
     */
    private $content;

  // и еще горстка геттеров и сеттеров для записи и чтения свойств
}

```

Обратите внимание на то, что аннотации помимо привычных типов данных (например, String) могут также задавать тип ссылок на дочерние или родительские документы.

Для незнакомых с паттерном Data mapper может показаться, что такие классы немного похожи на [Active record](https://en.wikipedia.org/wiki/Active_record_pattern) (привет, рельсовики и Yii-шники), однако таковыми они все равно не являются.

Как работать с таким документом?

```php
require_once '../bootstrap.php';

// сначала находим корневой узел
$rootDocument = $documentManager->find(null, '/');

// создаем новый документ
$doc = new \Demo\Document();
$doc->setParent($rootDocument);
$doc->setName('doc');
$doc->setTitle('My first document');
$doc->setContent('The document content');

// создаем второй, дочерний для первого
$childDocument = new \Demo\Document();
$childDocument->setParent($doc);
$childDocument->setName('child');
$childDocument->setTitle('My child document');
$childDocument->setContent('The child document content');


// сообщаем менеджеру документов о том, какие документы у нас готовые для сохранения
$documentManager->persist($doc);
$documentManager->persist($childDocument);

// отправляем все изменения, вставки и т.д. в бэкенд
$documentManager->flush();
```

```php
require_once '../bootstrap.php';

$doc = $documentManager->find(null, "/doc");
echo 'Found '.$doc->getId() ."\n";
echo 'Title: '.$doc->getTitle()."\n";
echo 'Content: '.$doc->getContent()."\n";
foreach($doc->getChildren() as $child) {
    if ($child instanceof \Demo\Document) {
        echo 'Has child '.$child->getId() . "\n";
    } else {
        echo 'Unexpected child '.get_class($child)."\n";
    }
}

$documentManager->remove($doc);

// удаляем документ
$documentManager->flush();

```

Небольшое замечание — в ORM привычно получать данные с помощью запросов. В ODM для этого надо использовать иерархию. Впрочем, можно и [запросы делать](http://docs.doctrine-project.org/projects/doctrine-phpcr-odm/en/latest/reference/working-with-objects.html#workingobjects-query), если сильно хочется.

В PHPCR ODM уже реализованы две очень важные функции — версионность и многоязычность. Начнем с первого.

Версионность в PHPCR бывает двух видов — simpleVersionable и (full) versionable. Для простой версионности предусмотрены ```checkin```/```checkout```-методы и линейная история изменений. Чек-ин создает новую версию узла и делает доступной только для чтения, чтобы что-то записать, нужно сделать чек-аут.

Полная версионность вдобавок к этому поддерживает нелинейную историю версий (для которой хелпер-методов у PHPCR-ODM пока нет) и метки (которые планируется добавить, как только их начнет поддерживать Jackalope). Для каждого узла можно добавить метку к версии, но за всю историю каждого узла метка не может повторяться дважды (то есть, если хочется пометить другую версию, нужно сначала снять ее со старой версии). 

Полная версионность соответсвует типу ```mix:versionable``` из PHPCR и позволяет создавать ветвление. К сожалению, PHPCR Version API не поддерживается PHPCR ODM целиком, для полноценной работы пока приходится работать с ```PHPCR\VersionManager``` напрямую через PHPCR-сессию. Подробнее об этом [тут](http://github.com/phpcr/phpcr/blob/master/doc/Tutorial.md) и [тут](http://www.day.com/specs/jcr/2.0/15_Versioning.html).

Имена версий генерируются PHPCR и не контролируются приложениям. Концепция коммит-месседжей отсутствует (просто пока не потребовалось). В любом случае, никто не мешает завести в документе поле под это дело.

Старые версии недоступы для модификации и сохранения изменений (исключение — при использовании методов restoreVersion и removeVersion).

Чтобы включить поддержку версионности для какого-то документа, нужно явным образом указать это в аннотации:

```php
/**
 * @Document(versionable="simple")
 */
class MyPersistentClass
{
    /** @VersionName */
    private $versionName;

    /** @VersionCreated */
    private $versionCreated;
}
```

Документации по тому, как работать с версиями, практически нет, авторы советуют обращаться в Phpdoc-комментарии в исходном коде. Поэтому надолго задерживаться на таких высоких материях не будем, посмотрим небольшой пример и пойдем дальше.

```php
$article = new Article();
$article->id = '/test';
$article->topic = 'Test';
$dm->persist($article);
$dm->flush();

// создаем слепок версии документа на основе текущего состояния
$dm->checkpoint($article);

$article->topic = 'Newvalue';
$dm->flush();

// получаем информацию о версиях
$versioninfos = $dm->getAllLinearVersions($article);
$firstVersion = reset($versioninfos);
// используем ее для получения слепка старой версии
$oldVersion = $dm->findVersionByName(null, $article->id, $firstVersion['name']);

echo $oldVersion->topic; // "Test"

// ищем новейшую версию
$article = $dm->find('/test');
echo $article->topic; // "Newvalue"

// устанавливаем старую версию в качестве последней
$dm->restoreVersion($oldVersion);

// документ обновился
echo $article->topic; // "Test"

// создаем еще одну версию, чтобы продемонстрировать удаление
$article->topic = 'Newvalue';
$dm->flush();
$dm->checkpoint($article);

// удаляем старую версию из истории (с последней так сделать не дадут)
$dm->removeVersion($oldVersion);
```

Теперь про многоязычность. Любое свойство документа можно пометить как переводимое. Несмотря на то, что при переводе в дереве будет склонирован документ целиком, поля, которым перевод не требуется, копироваться почем зря не будут. Каждый раз указывать язык для работы явно не требутся — достаточно один раз сказать DocumentManager, какой язык нам нужен, и дальше для всех вызовов типа ```find()``` и создания новых документов будет использоваться именно он. Удобно:

```php
/**
 * @PHPCRODM\Document(translator="attribute")
 */
class MyPersistentClass
{
  /**
   * Текущая локаль документа
   * @Locale
   */
  private $locale;

  /**
   * Непереведенное свойство
   * @Date
   */
  private $publishDate;

  /**
   * Переведенное свойство
   * @String(translated=true)
   */
  private $topic;

  /**
   * Зависимая от языка картинка
   * @Binary(translated=true)
   */
  private $image;
}
```

И вот непосредственно работа с переводом полей:

```php

// заранее загружаем DocumentManager (пример в документации)

$localePrefs = array(
    'en' => array('fr'),
    'fr' => array('en'),
);

$dm = new \Doctrine\ODM\PHPCR\DocumentManager($session, $config);
$dm->setLocaleChooserStrategy(new LocaleChooser($localePrefs, 'en'));

// затем используем перевод:

$doc = new Article();
$doc->id = '/my_test_node';
$doc->author = 'John Doe';
$doc->topic = 'An interesting subject';
$doc->text = 'Lorem ipsum...';

// сохраняем документ на английском
$dm->persist($doc);
$dm->bindTranslation($doc, 'en');

// изменяем содержимое одного из полей и сохраняем на французском
$doc->topic = 'Un sujet intéressant';
$dm->bindTranslation($doc, 'fr');

// автоматически обновилась локаль
echo $doc->locale; // fr

// записываем изменения в PHPCR
$dm->flush();

// получаем документ на языке по умолчанию
// (английский в данном случае)
$doc = $dm->find(null, '/my_test_node');

// получаем документ на французском
$doc = $dm->findTranslation(null, '/my_test_node', 'fr');
$doc->title = 'nouveau';
$dm->flush(); // обновляем документ на французском, язык отслеживается менеджером документов
```

На текущий момент для всех ссылок, включая родительские и дочерние, предусмотрен фоллбек к языку по умолчанию, поскольку на время сессии можно отслеживать только один документ. Авторы пока не уверены, как поступить лучше, причем также открым пока висит вопрос обработки незавершенных документов (когда поля, заявленные в документе, на деле не существуют). Впрочем, время покажет, как эти проблемы будут решены. Помимо этого в будущем добавят логирование, кэширование результатов и начнут обновлять документацию (с этим пока очень скудно).

Таким образом, при использовании ODM стек выглядит следующим образом:
* PHPCR (с бэкендом в виде Jackalope/Midgard2, в случае последнего будут нужны ```pdo_``` библиотеки для работы с RDBMS)
* Doctrine Common
* PHPCR-ODM