Продолжим разглядывать [Symfony CMF](http://cmf.sandbox.com). В первой части статьи мы подробно рассмотрели схему хранения и доступа к данным, во второй части нас ждет все остальное.

Самые нетерпеливые могут промотать вниз? скачать виртуальную машину с установленной системой (потребуется VirtualBox) и пощупать все самому, но для полноты опыта я бы рекомендовал сначала прочитать статью.

Итак.

#### Шаблонизатор
Здесь все знакомо для многих — используется [Twig](http://twig.sensiolabs.org). Гибкий, мощный, очень быстрый и лаконичный. Поддерживает разделение на блоки, наследование и компиляцию шаблонов в PHP-код. Шаблон главной страницы выглядит так:

```Twig
{% extends "SandboxMainBundle::skeleton.html.twig" %}

{% block content %}
    <p><em>We are on the homepage which uses a special template</em></p>

    {% createphp cmfMainContent as="rdf" %}
    {{ rdf|raw }}
    {% endcreatephp %}

    <hr/>

    {{ sonata_block_render({ 'name': 'additionalInfoBlock' }, {
        'divisible_by': 3,
        'divisible_class': 'row',
        'child_class': 'span3'
    }) }}

    <div class="row">
        <div class="span3">
            <h2>Some additional links:</h2>
            <ul>
                {% for child in cmf_children(cmf_find('/cms/simple')) %}
                    <li>
                        <a href="{{ path(child) }}">{{ child.title|striptags }}</a>
                    </li>
                {% endfor %}
            </ul>
        </div>

        <div class="span3">
        {{ sonata_block_render({
            'name': 'rssBlock'
        }) }}
        </div>
    </div>
{% endblock %}
```
Больше тут смотреть не на что, Twig – он и в Африке Twig.

#### Статический контент
Статический контент в CMS — основа всего. В Symfony CMF за статический контент отвечает ContentBundle, который обеспечивает базовую реализацию классов статических документов, включая многоязычность и связь с маршрутами.

Основой бандла является класс ```StaticContent```, состав которого окажется знакомым многим — говорящие сами за себя поля типа ```title```, ```body```, ссылка на родительский документ и так далее. Кроме того, он реализует два интерфейса:

* ```RouteReferrersInterface```, обеспечивает связку с маршрутами
* ```PublishWorkflowInterface```, помогает показывать или скрывать контент в с помощью заданных дат публикации

Для мультиязычных документов предусмотрен ```MultilangStaticContent``` — все то же самое, но добавлен перевод полей и объявление локали. Как делается перевод — мы уже видели в первой части статьи.

Бандлу полагается контроллер. ```ContentController``` состоит из единственного ```indexAction```, который на входе принимает желамый документ и рендерит его на нужном языке, если с датами публикации все в порядке. Опционально можно задать шаблон, с которым будет выводиться страница. Если не задать — будет взят тот, что указан по умолчанию.

#### Роутинг
В современных больших сайтах количество материалов может легко измеряться тысячами. Помножить на количество переводов. Добавить необходимость постоянных правок материалов и URL-ов к ним во имя поисковой оптимизации.
При этом, заметьте, такими вещами обычно занимается администратор сайта (вебмастер, контент-менеджер, сеошник), а не разработчик.

Какие требования предъявляются к роутингу в таком случае?

* URL задается пользователем
* поддержка многосайтовости
* поддержка многоязычности
* древовидная структура
* контент, меню и маршруты должны быть разделены

Если вспомнить стандартный роутер Symfony 2, становится понятно, что такой гибкости там не достичь. Роуты явно прописаны в конфиге для каждого контроллера и пользователю менять их попросту не дают. Максимум, на что можно рассчитывать — это какой-нибудь ```/page/{slug}```, который великодушно можно править из админки.

Давайте посмотрим, как выглядела схема функционирования на голом SF2:

![Роутинг в SF2](http://habrastorage.org/storage2/901/ddf/2bf/901ddf2bfb8dde7d386eaf6f46d80c0a.png "Роутинг в SF2")

Если не вдаваться в детали возможностей конфигурирования параметров, все довольно примитивно. Приходит запрос, роутер решает, какой вызвать контроллер, контроллер дергает нужные данные и рендерит вьюшку, затем выдает заветный Response.

Это достаточно привычная схема. 

Почему такой вариант недостаточно хорош для CMS?

Представим, что у нас есть некий ```PageController```, который принимает в качестве аргумента URL-псевдоним страницы, сравнивает его с тем, что хранится в базе данных и выдает страничку, либо 404.

В моей практике встречались случаи, когда среди статичного контента встречались разные формочки, которые гармоничней смотрелись в составе раздела сайта, нежели как отдельный компонент. Например, на одном сайте банка в URL текстового раздела ```/private/credits/cash``` добавлялся кредитный ```/calculator```, чтобы люди, прочитав необходимую информацию о кредитах, на месте могли посчитать себе нужные циферки.

Допустим, ```PageController``` обработает первую часть URL, что делать с калькулятором, который, очевидно, будет выступать отдельным контроллером? Дописать в конфиге ```pattern: /private/cash/credits/calculator``` и указать отдельный контроллер? Как-то некрасиво. Даже если расставить приоритеты между остальными маршрутами, совершенно очевидно, что гибкостью тут не пахнет — если изменится псевдоним в базе, руками придется править и конфиг.

Нужно что-то другое.

Резюмируем роутинг в SF2:

* определяется, какой контроллер обслуживает запрос
* парсятся параметры URL
* если ничего не получилось, поведение по умолчанию основывается на заранее конфигурированном наборе роутов
  * либо из конфигурации
  * либо из бандлов
* пользователи редактировать роуты не могут
* не масштабируется до очень большого количества роутов
* в CMS *пользователь* сам хочет решать, что по какому адресу должно лежать.

##### Концепция маршрутизации в Symfony CMF
От прекрасного и мощного, но неудобного в случае с CMS роутера Symfony 2 пришлось отказаться в пользу новой концепции:

* нужно отделять дерево контента от навигационного дерева
* навигационное дерево состоит из *ссылок* на элементы дерева контента. За счет этого егко реализуются:
  * многосайтовость (настольная, планшетная, мобильные версии)
  * мультиязычность
* переботка навигации требует клонирования навигационного дерева
* по готовности результат вливается обратно

Сразу на ум приходит решение в лоб: создаем маршрут по умолчанию (```/{url}``` с обязательным параметром ```url: .*```), один контроллер для всех запросов и в зависимости от содержимого перенаправляем запрос в другие контроллеры. Но при этом никто не отменяет конфликтов с другими роутами.

```yml
navigation:
    pattern: "/{url}"
    defaults: { _controller: service.controller:indexAction }
    requirements:
        url: .*

```
Звучит по-прежнему не очень.

Решение получше предоставлял (пока его не пометили как устаревший со времен Symfony 2.1) ```DoctrineRouter```. Он уже гораздо гибче, потому что искал маршруты по URL в базе данных, при этом была готова реализация для документов через PHPCR-ODM, а еще можно приделать любую свою. Маршрут по желанию явно указывал контроллер, в противном случае использовался ```ControllerResolver```, который пытался сам решить, какой контроллер будет обрабатывать запрос. Были и встроенные распознаватели:

* привязка узлов определенного типа к контроллеру
* привязка узлов определенного типа к шаблону и использование стандартного (generic) контроллера

Для своих распознавателей предусмотрен интерфейс:

```php
interface ControllerResolverInterface
{
   function getController(RouteObjectInterface $document,
                          array &$defaults);
}
```

До кучи — переадресация маршрутов (на другие роуты или абсолютные URL). 

На данный момент для решения всех проблем с роутингом в Symfony CMF используются два компонента — ```ChainRouter``` и ```DynamicRouter```. Первый заменяет стандартный SF2-роутер и, несмотря на название, работу роутера (определение контроллера для обработки запроса) на самом деле не выполняет. Вместо этого он дает возможность добавлять свои роутеры в список-цепочку. В цепочке обработать запрос попробуют все сконфигурированные роутеры по очереди, в порядке приоритета. Сервисы роутеров ищутся по тегам.

```yaml
# app/config/config.yml
cmf_routing:
    chain:
        routers_by_id:
            # включаем the DynamicRouter с низким приоритетом
            # в этом случае нединамические маршруты сработают раньше
            # чтобы не допускать лишнего похода в базу данных
            cmf_routing.dynamic_router: 20

            # подключаем свой роутер
            acme_core.my_router: 50
            
            # дефолтный роутер включаем с высоким приоритетом
            router.default: 100


services:
    acme_core.my_router:
        class: %my_namespace.my_router_class%
        tags:
            - { name: cmf_routing.router, priority: 300 }
```

Ну вот, у нас есть бесконечное количество доступных для использования роутеров.

Теперь вспоминаем про поиск роутов в базе данных и ```DynamicRouter```. Его задачей является загрузка маршрутов из *провайдера*, провайдером может быть (и как правило является) база данных. В стандартной поставке есть реализации провайдеров для Doctrine PHPCR-ODM, Doctrine ORM и разумеется, можно дополнить список провайдеров, реализовав [```RouteProviderInterface```](https://github.com/symfony-cmf/Routing/blob/master/RouteProviderInterface.php).

Что делают провайдеры? Провайдеры по запросу выдают упорядоченное подмножество маршрутов-кандидатов, которые могут подойти пришедшему запросу, а ```DynamicRouter``` принимает окончательное решение и сопоставляет запрос с конкретным объектом типа ```Route```.

Маршрут определяет, какой контроллер будет обрабатывать определенный запрос. ```DynamicRouter``` использует несколько методов в порядке убывания приоритета: 

* явно: ```Route```-документ сам точно объявляет конечный контроллер, если таковой возвращается из вызова ```getDefault('_controller')```.
* по псевдониму: маршрут возвращается значение ```getDefault('type')```, которое сопоставляется с конфигурацией из ```config.yml```
* по классу: ```Route```-документ должен реализовать ```RouteObjectInterface``` и вернуть объект для ```getContent()```. Возвращаемый тип класса опять же сопоставляется с конфигом
* по умолчанию: будет использоваться дефолтный контроллер, если таковой указан сконфигурирован

Аналогично (явно или по классу) маршрут может задавать и шаблон, с которым должна рендериться страница.

По желанию при помощи вышеупомянутого ```RouteObjectInterface``` можно научить маршрут возвращать экземляр модели, ассоцированный с ним

Поддерживаются и редиректы. Вообще есть интерфейс ```RedirectRouteInterface```, но для PHPCR-ODM готова реализация в виде документа ```RedirectRoute```. Он может перенаправлять на абсолютный URI, на именованный машрут, сгенерированный любым роутером в цепочке.

Еще одна важная фича, о которой может быть интересно узнать тем, кто с Symfony не работал — это двунаправленность роутера. Помимо распознавания маршрутов на основе заданных параметров, эти маршруты можно и генерировать, используя те же самые параметры. В отличие от стандартного роутера SF2, в качестве параметра для функции ```path()``` можно передавать не только заданное в конфиге имя маршрута, но и реализацию  ```RouteObjectInterface```, ```RouteReferrersInterface``` (то есть объект-маршрут), либо ссылку на объект в репозитории, используя его content_id:

```twig
{# myRoute это объект класса Symfony\Component\Routing\Route #}
<a href="{{ path(myRoute) }}>Read on</a>

{# Создает ссылку на / для этого сервера #}
<a href="{{ path('/cms/routes') }}>Home</a>

{# myContent реализует RouteReferrersInterface #}
<a href="{{ path(myContent) }}>Read on</a>

{# передаем ссылку на объект, который реализует ContentRepositoryInterface #}
<a href="{{ path(null, {'content_id': '/cms/content/my-content'}) }}>
    Read on
</a>
```
Если для одного и того же материала подходит несколько маршрутов, предпочтительным будет считаться тот, локаль которого совпадает с локалью запроса.

Напоследок вернемся к написанному чуть ранее, разделение навигационного дерева и дерева контента. Взгляните на схему, разветвленная навигация согласно определенным правилам передает управление необходимым контроллерам и только после этого запрашивает данные:

![Связь между роутингом и контентом](http://habrastorage.org/storage2/377/f40/85a/377f4085a80fcb86a3204c7125a770d4.png "Связь между роутингом и контентом")

На это с маршрутизацией закончим.

#### Меню
Ни одна CMS не обходится без системы меню. Хотя структура меню обычно повторяет структуру контента, ему может потребоваться собственная логика, не определенная контентом или существующая в нескольких контекстах с разными опциями.

![Пример меню](http://habrastorage.org/storage2/ef2/803/327/ef2803327ed4df7bf0dd4de365698076.png "Пример меню")

В состав Symfony CMF входит MenuBundle, инструмент, позволяющий динамически задавать собственные меню. Он расширяет известный KnpMenuBundle, дополняя его иерархическими и мультиязычными элементами и инструментами для их записи в выбранное хранилище.

При выводе меню MenuBundle опирается на дефолтные для KnpMenuBundle рендереры и хелперы. [Полную документацию](https://github.com/KnpLabs/KnpMenuBundle/blob/master/Resources/doc/index.md) почитать рекомендуется, но вообще в самом простейшем случае вывод выглядит так:

```twig
{{ knp_menu_render('simple') }}
```
Переданное функции имя меню в свою очередь будет передано реализации ```MenuProviderInterface```, которая будет решать, какое меню нужно показать.

В основе бандла лежит ```PhpcrMenuProvider```, реализация ```MenuProviderInterface```, ответственная за динамическую загрузку меню из PHPCR-хранилища. По умолчанию сервис провайдера конфигурируется параметром ```menu_basepath```, который указывает, где искать меню в PHPCR-дереве. При рендеринге меню передается параметр ```name```, который должен быть прямым потомком указанного базового пути. Это позволяет ```PhpcrMenuProvider``` работать с несколькими иерархиями меню, используя единый механизм хранения. Вспоминая указанный выше пример использования, меню ```simple``` должно находиться по адресу ```/cms/menu/simple```, если в конфигурации указано следующее:

```yml
cmf_menu:
    menu_basepath: /cms/menu
```
В бандле поддерживается два типа узлов: ```MenuNode``` и ```MultilangMenuNode```. ```MenuNode``` содержит информацию об отдельном пункте меню: ```label```, ```uri```, список дочерних пунктов ```children```, ссылку на маршут, связанный Content-элемент, плюс список атрибутов ```attributes```, благодаря которому можно настраивать вывод меню.

```MultilangMenuNode``` расширяет ```MenuNode``` для поддержки мультиязычности: добавлено поле ```locale``` для определения перевода, к которому принадлежит пункт и ```label``` с ```uri```, помеченные как ```translated=true```. Это единственные поля, которые различаются между переводами.

Для интеграции с админкой предусмотрены панели и сервисы для SonataDoctrinePhpcrAdminBundle (о нем ниже). Панели доступны сразу, но чтобы использовать их, надо явно добавить и в дашборд. 

Конфигурируется бандл [как обычно][1], но все параметры опциональны.

Связь между роутингом, меню и контентом:
![Роутинг, контент, меню](http://habrastorage.org/storage2/c64/a28/8ca/c64a288caf48db7bd73740a108efe85e.png "Роутинг, контент, меню")

### BlockBundle
![Блоки](http://habrastorage.org/storage2/e85/ae0/46b/e85ae046bd50f4648eeeb00d2f03b339.png "Блоки")
### Frontend Editing
![Редактирование на фронтенде](http://habrastorage.org/storage2/0e9/f3f/a11/0e9f3fa114236e17b12d75a8e21af5b7.png "Редактирование на фронтенде")

### Админка
### И многое другое
Планируется (а местами в какой-то степени даже готова) интеграция с модулями:
* SymfonyCmfSearchBundle (полноценный поиск, расширяет LiipSearchBundle)
* SymfonyCmfSimpleCms (простейшая CMS, поставляемая вместе с CMF)
* LuneticsLocaleBundle (автоматическое определение локали)
* и другие бандлы от Sonata.




#### Установка
По большому счету, можно сразу скачать подготовленный мной [образ виртуальной машины]() для VirtualBox, где установлено и настроено все, включая разные бэкенды. Для удобства можно прописать к себе в hosts-файл ```192.168.3.3 cmf-sandbox``` и зайти туда через браузер.

Если по каким-то причинам вам не хочется с этим возиться, даю [ссылку](http://cmf.liip.ch/en) на онлайн-песочницу, но туда не залезешь поковыряться внутрь, хотя посмотреть на скорую руку тоже сгодится.

Вручную устанавливать немного муторно, поэтому подробно останавливаться на каждом шаге, описанном в [инструкции](http://symfony.com/doc/master/cmf/book/installation.html) я не буду. Просто кратко пройдусь по основным моментам.

Итак, требования к машине для запуска CMF немного нестандартные, хотя никакого криминала.

Во-первых, нужно удовлетворить стандартные потребности для Symfony 2 (весьма вероятно, что с этим уже все в порядке):

* установить PHP 5.3.3 или выше
* включить поддержку JSON
* включить поддержку ctype
* в ```php.ini``` корректно установить ```date.timezone```
* PDO для Doctrine

[Все остальное](http://symfony.com/doc/current/reference/requirements.html) (APC и так далее) — по желанию.

Далее идут требования Symfony CMF. По умолчанию для хранения данных используется SQLite, поэтому проверяем, чтобы было установлено расширение ```pdo_sqlite```.

Чтобы использовать другие бэкенды, устанавливаем:

* [Apache Jackrabbit](http://jackrabbit.apache.org/downloads.html) и соответственно Java.
* [Midgard2 PHPCR](http://midgard-project.org/phpcr/) и его расширение для PHP. К сожалению, пакетов для этого пока мало: они либо помечены, как нестабильные (я брал в sid в случае с Debian), либо собраны далеко не под все платформы, либо собраны, но для устаревших версий ОС. В целом, если поискать, можно найти и RPM, и deb-пакеты. На крайний случай расширение можно собрать из [исходников](https://github.com/midgardproject/midgard-php5).


  [1]: http://symfony.com/doc/current/cmf/reference/configuration/menu.html