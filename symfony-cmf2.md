## Symfony CMF
Проект [Symfony CMF](http://cmf.symfony.com) призван упростить разработку функционала, присущего CMS, для всех, кто использует в работе Symfony Framework 2.
Основные особенности проекта:
* Слабая связность компонентов
* Масштабируемость
* Удобство
* Тестируемость
* Жокументация

Стоит сделать акцент на слове **CMF** — проект не является CMS сам по себе, это именно **фреймворк**. В отличие от CMS, где все компоненты жестко завязаны друг на друге, в Symfony CMF вы:
* используете все, что можно
* заменяете то, что не нравится
* игнорируете то, что не требуется

То есть, вам дан набор модульных инструментов для разработки, а не готовое приложение «под ключ».

Давайте посмотрим, как выглядела схема функционирования на голом SF2:
![Роутинг в SF2](http://habrastorage.org/storage2/901/ddf/2bf/901ddf2bfb8dde7d386eaf6f46d80c0a.png "Роутинг в SF2")

А вот как выглядит та же схема с дополнениями от CMF:
![Роутинг в CMF](http://habrastorage.org/storage2/9d5/f3f/5b5/9d5f3f5b5ac44fee2500700fc1a928db.png "Роутинг в CMF")

### Роутинг
CMF предоставляет более интересные возможности роутинга, в отличие от базового варианта SF2.

#### Роутинг в SF2:
* определяется, какой контроллер обслуживает запрос
* парсятся параметры URL
* если ничего не получилось, поведение по умолчанию основывается на заранее конфигурированном наборе роутов
  * либо из конфигурации
  * либо генерируется из бандлов
* пользователи редактировать роуты не могут
* не масштабируется до очень большого количества роутов
* а ведь в CMS *пользователь* сам хочет решать, что по какому адресу должно лежать.

#### Концепция маршрутизации в Symfony CMF:
* возможность отделять дерево контента от навигационного дерева
* навигационное дерево состоит из *ссылок* дерево контента.
  * многосайтовость (настольная, планшетная, мобильные версии)
  * мультиязычность
* переботка навигации требует клонирования навигационного дерева
* по готовности результат вливается обратно

#### Решение в лоб
* создаем маршрут по умолчанию, ```/{url}``` с обязательным параметром ```url: .*```
* один контроллер для всех запросов (но в зависимости от содержимого может перенаправлять запрос в другие)
* возможны конфликты с другими маршрутами

```yml
navigation:
    pattern: "/{url}"
    defaults: { _controller: service.controller:indexAction }
    requirements:
        url: .*
```

#### Решение чуть лучше
DoctrineRouter.
* гибкость
* поиск в базе данных
* генерирует URL из контента, на который ссылается маршрут

##### DoctrineRouter, Обработка адресов
* ищет маршрут по URL в базе данных
  * готова реализация на PHPCR ODM
  * можно приделать свою
* построен поверх стандартного роутера SF2
* роут может явно указывать контроллер
* если не получилось выяснить, какой требуется контроллер, в дело идет Controller Resolver
* поддерживается переадресация маршрутов (на другие роуты или абсолютные URL)

##### DoctrineRouter, ControllerResolver
* выясняет, какой контроллер должен обрабатыать запрошенный узел
* встроенные распознаватели:
  * привязка узлов определенного типа к контроллеру
  * привязка узлов определенного типа к шаблону и использование стандартного (generic) контроллера
* можно добавлять собственные распознаватели:

```php
interface ControllerResolverInterface
{
   function getController(RouteObjectInterface $document,
                          array &$defaults);
}
```


#### Решение Symfony CMF
**Chain Router!**
* комбинирует оба подхода (стандартный и DoctrineRouter)
* дает возможность добавлять свои роутеры
* сервисы роутеров ищутся по тегам
* запрос пытаются обработать все сконфигурированные роутеры
* но при этом — в порядке приоритета
* законченное и готовое для использования в продакшене решение.

```xml
<service id="my_namespace.my_router"
  class="%my_namespace.my_router_class%">
  <tag name="router" priority="300" />
</service>
```
Вернемся к написанному чуть ранее, разделение навигационного дерева и дерева контента. Взгляните на схему, разветвленная навигация согласно определенным правилам передает управление необходимым контроллерам и только после этого запрашивает данные:
![Связь между роутингом и контентом](http://habrastorage.org/storage2/377/f40/85a/377f4085a80fcb86a3204c7125a770d4.png "Связь между роутингом и контентом")


### Меню
![Пример меню](http://habrastorage.org/storage2/ef2/803/327/ef2803327ed4df7bf0dd4de365698076.png "Пример меню")
* предоставляет NodeInterface с документами PHPCR ODM
* рендерер меню: если MenuItem определяет контент
  * сгенерировать маршрут исходя из контента
  * определить активный элемент меню исходя из запроса
* в противном случае элемент обрабатывается обычным рендерером
* с PHPCR ODM мультиязычные меню делаются очень легко (см. MultilangMenuItem в MenuBundle)
* и даже хлебные крошки есть.

Связь между роутингом, меню и контентом:
![Роутинг, контент, меню](http://habrastorage.org/storage2/c64/a28/8ca/c64a288caf48db7bd73740a108efe85e.png "Роутинг, контент, меню")

### Content Bundle
### PHPCR ODM
![PHPCR ODM](http://habrastorage.org/storage2/6bc/f46/d7a/6bcf46d7ae14540b2cc40e014849ef83.png "PHPCR ODM")
### BlockBundle
![Блоки](http://habrastorage.org/storage2/e85/ae0/46b/e85ae046bd50f4648eeeb00d2f03b339.png "Блоки")
### Frontend Editing
![Редактирование на фронтенде](http://habrastorage.org/storage2/0e9/f3f/a11/0e9f3fa114236e17b12d75a8e21af5b7.png "Редактирование на фронтенде")
### Админка
### И многое другое
Планируется (а местами в какой-то степени даже готова) интеграция с модулями:
* SymfonyCmfSearchBundle (полноценный поиск, расширяет LiipSearchBundle)
* SymfonyCmfSimpleCms (простейшая CMS, поставляемая вместе с CMF)
* LuneticsLocaleBundle (автоматическое определение локали)
* и другие бандлы от Sonata.