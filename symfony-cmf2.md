Продолжим разглядывать [Symfony CMF](http://cmf.sandbox.com). В первой части статьи мы подробно рассмотрели схему хранения и доступа к данным, во второй части нас ждет все остальное.

Самые нетерпеливые могут промотать вниз? скачать виртуальную машину с установленной системой (потребуется VirtualBox) и пощупать все самому, но для полноты опыта я бы рекомендовал сначала прочитать статью.

Итак.

#### Статический контент
Статический контент в CMS — основа всего. В Symfony CMF за статический контент отвечает ContentBundle, который обеспечивает базовую реализацию классов статических документов, включая многоязычность и связь с маршрутами.

Основой бандла является класс ```StaticContent```, состав которого окажется знакомым многим — говорящие сами за себя поля типа ```title```, ```body```, ссылка на родительский документ и так далее. Кроме того, он реализует два интерфейса:

* ```RouteReferrersInterface```, обеспечивает связку с маршрутами
* ```PublishWorkflowInterface```, помогает показывать или скрывать контент в с помощью заданных дат публикации

Для мультиязычных документов предусмотрен ```MultilangStaticContent``` — все то же самое, но добавлен перевод полей и объявление локали. Как делается перевод — мы уже видели в первой части статьи.

Бандлу полагается контроллер. ```ContentController``` состоит из единственного ```indexAction```, который на входе принимает желамый документ и рендерит его на нужном языке, если с датами публикации все в порядке. Опционально можно задать шаблон, с которым будет выводиться страница. Если не задать — будет взят тот, что указан по умолчанию.

#### Роутинг
В современных больших сайтах количество материалов может легко измеряться тысячами. Помножить на количество переводов. Добавить необходимость постоянных правок материалов и URL-ов к ним во имя поисковой оптимизации.
При этом, заметьте, такими вещами обычно занимается администратор сайта (вебмастер, контент-менеджер, сеошник), а не разработчик.

Какие требования предъявляются к роутингу в таком случае?

* URL задается пользователем
* поддержка многосайтовости
* поддержка многоязычности
* древовидная структура
* контент, меню и маршруты должны быть разделены

Если вспомнить стандартный роутер Symfony 2, становится понятно, что такой гибкости там не достичь. Роуты явно прописаны в конфиге для каждого контроллера и пользователю менять их попросту не дают. Максимум, на что можно рассчитывать — это какой-нибудь ```/page/{slug}```, который великодушно можно править из админки.

Давайте посмотрим, как выглядела схема функционирования на голом SF2:

![Роутинг в SF2](http://habrastorage.org/storage2/901/ddf/2bf/901ddf2bfb8dde7d386eaf6f46d80c0a.png "Роутинг в SF2")

Если не вдаваться в детали возможностей конфигурирования параметров, все довольно примитивно. Приходит запрос, роутер решает, какой вызвать контроллер, контроллер дергает нужные данные и рендерит вьюшку, затем выдает заветный Response.

Это достаточно привычная схема. 

Почему такой вариант недостаточно хорош для CMS?

Представим, что у нас есть некий ```PageController```, который принимает в качестве аргумента URL-псевдоним страницы, сравнивает его с тем, что хранится в базе данных и выдает страничку, либо 404.

В моей практике встречались случаи, когда среди статичного контента встречались разные формочки, которые гармоничней смотрелись в составе раздела сайта, нежели как отдельный компонент. Например, на одном сайте банка в URL ```/private/credits/cash``` добавлялся ```/calculator```, чтобы люди, прочитав необходимую информацию о кредитах, на месте могли посчитать себе нужные циферки.

Допустим, ```PageController``` обработает первую часть URL, что делать с калькулятором, который, очевидно, будет выступать отдельным контроллером? Дописать в конфиге ```pattern: /private/cash/credits/calculator``` и указать отдельный контроллер? Как-то некрасиво. Даже если расставить приоритеты между остальными маршрутами, совершенно очевидно, что гибкостью тут не пахнет — если изменится псевдоним в базе, руками придется править и конфиг.

Нужно что-то другое.

Резюмируем роутинг в SF2:

* определяется, какой контроллер обслуживает запрос
* парсятся параметры URL
* если ничего не получилось, поведение по умолчанию основывается на заранее конфигурированном наборе роутов

  * либо из конфигурации
  * либо из бандлов
* пользователи редактировать роуты не могут
* не масштабируется до очень большого количества роутов
* в CMS *пользователь* сам хочет решать, что по какому адресу должно лежать.

##### Концепция маршрутизации в Symfony CMF
От прекрасного и мощного, но неудобного в случае с CMS роутера Symfony 2 пришлось отказаться в пользу новой концепции:

* нужно отделять дерево контента от навигационного дерева
* навигационное дерево состоит из *ссылок* на элементы дерева контента. За счет этого егко реализуются:
  * многосайтовость (настольная, планшетная, мобильные версии)
  * мультиязычность
* переботка навигации требует клонирования навигационного дерева
* по готовности результат вливается обратно

##### Решение в лоб
* создаем маршрут по умолчанию, ```/{url}``` с обязательным параметром ```url: .*```
* один контроллер для всех запросов (но в зависимости от содержимого может перенаправлять запрос в другие)
* возможны конфликты с другими маршрутами

```yml
navigation:
    pattern: "/{url}"
    defaults: { _controller: service.controller:indexAction }
    requirements:
        url: .*
```

##### Решение чуть лучше
DoctrineRouter.
* гибкость
* поиск в базе данных
* генерирует URL из контента, на который ссылается маршрут

###### DoctrineRouter, Обработка адресов
* ищет маршрут по URL в базе данных
  * готова реализация на PHPCR ODM
  * можно приделать свою
* построен поверх стандартного роутера SF2
* роут может явно указывать контроллер
* если не получилось выяснить, какой требуется контроллер, в дело идет Controller Resolver
* поддерживается переадресация маршрутов (на другие роуты или абсолютные URL)

###### DoctrineRouter, ControllerResolver
* выясняет, какой контроллер должен обрабатыать запрошенный узел
* встроенные распознаватели:
  * привязка узлов определенного типа к контроллеру
  * привязка узлов определенного типа к шаблону и использование стандартного (generic) контроллера
* можно добавлять собственные распознаватели:

```php
interface ControllerResolverInterface
{
   function getController(RouteObjectInterface $document,
                          array &$defaults);
}
```


##### Решение Symfony CMF
**Chain Router!**
* комбинирует оба подхода (стандартный и DoctrineRouter)
* дает возможность добавлять свои роутеры
* сервисы роутеров ищутся по тегам
* запрос пытаются обработать все сконфигурированные роутеры
* но при этом — в порядке приоритета
* законченное и готовое для использования в продакшене решение.

```xml
<service id="my_namespace.my_router"
  class="%my_namespace.my_router_class%">
  <tag name="router" priority="300" />
</service>
```
Вернемся к написанному чуть ранее, разделение навигационного дерева и дерева контента. Взгляните на схему, разветвленная навигация согласно определенным правилам передает управление необходимым контроллерам и только после этого запрашивает данные:
![Связь между роутингом и контентом](http://habrastorage.org/storage2/377/f40/85a/377f4085a80fcb86a3204c7125a770d4.png "Связь между роутингом и контентом")


#### Меню
![Пример меню](http://habrastorage.org/storage2/ef2/803/327/ef2803327ed4df7bf0dd4de365698076.png "Пример меню")

* предоставляет NodeInterface с документами PHPCR ODM
* рендерер меню: если MenuItem определяет контент
  * сгенерировать маршрут исходя из контента
  * определить активный элемент меню исходя из запроса
* в противном случае элемент обрабатывается обычным рендерером
* с PHPCR ODM мультиязычные меню делаются очень легко (см. MultilangMenuItem в MenuBundle)
* и даже хлебные крошки есть.

Связь между роутингом, меню и контентом:
![Роутинг, контент, меню](http://habrastorage.org/storage2/c64/a28/8ca/c64a288caf48db7bd73740a108efe85e.png "Роутинг, контент, меню")

### Content Bundle
### PHPCR ODM
![PHPCR ODM](http://habrastorage.org/storage2/6bc/f46/d7a/6bcf46d7ae14540b2cc40e014849ef83.png "PHPCR ODM")
### BlockBundle
![Блоки](http://habrastorage.org/storage2/e85/ae0/46b/e85ae046bd50f4648eeeb00d2f03b339.png "Блоки")
### Frontend Editing
![Редактирование на фронтенде](http://habrastorage.org/storage2/0e9/f3f/a11/0e9f3fa114236e17b12d75a8e21af5b7.png "Редактирование на фронтенде")

#### Система шаблонов
Здесь все знакомо для многих — используется [Twig](http://twig.sensiolabs.org). Гибкий, мощный, очень быстрый и лаконичный. Поддерживает разделение на блоки, наследование и компиляцию шаблонов в PHP-код. Шаблон главной страницы выглядит так:

```twig
{% extends "SandboxMainBundle::skeleton.html.twig" %}

{% block content %}
    <p><em>We are on the homepage which uses a special template</em></p>

    {% createphp cmfMainContent as="rdf" %}
    {{ rdf|raw }}
    {% endcreatephp %}

    <hr/>

    {{ sonata_block_render({ 'name': 'additionalInfoBlock' }, {
        'divisible_by': 3,
        'divisible_class': 'row',
        'child_class': 'span3'
    }) }}

    <div class="row">
        <div class="span3">
            <h2>Some additional links:</h2>
            <ul>
                {% for child in cmf_children(cmf_find('/cms/simple')) %}
                    <li>
                        <a href="{{ path(child) }}">{{ child.title|striptags }}</a>
                    </li>
                {% endfor %}
            </ul>
        </div>

        <div class="span3">
        {{ sonata_block_render({
            'name': 'rssBlock'
        }) }}
        </div>
    </div>
{% endblock %}
 ```

Больше тут смотреть не на что, Twig – он и в Африке Twig.

### Админка
### И многое другое
Планируется (а местами в какой-то степени даже готова) интеграция с модулями:
* SymfonyCmfSearchBundle (полноценный поиск, расширяет LiipSearchBundle)
* SymfonyCmfSimpleCms (простейшая CMS, поставляемая вместе с CMF)
* LuneticsLocaleBundle (автоматическое определение локали)
* и другие бандлы от Sonata.




#### Установка
По большому счету, можно сразу скачать подготовленный мной [образ виртуальной машины]() для VirtualBox, где установлено и настроено все, включая разные бэкенды. Для удобства можно прописать к себе в hosts-файл ```192.168.3.3 cmf-sandbox``` и зайти туда через браузер.

Если по каким-то причинам вам не хочется с этим возиться, даю [ссылку](http://cmf.liip.ch/en) на онлайн-песочницу, но туда не залезешь поковыряться внутрь, хотя посмотреть на скорую руку тоже сгодится.

Вручную устанавливать немного муторно, поэтому подробно останавливаться на каждом шаге, описанном в [инструкции](http://symfony.com/doc/master/cmf/book/installation.html) я не буду. Просто кратко пройдусь по основным моментам.

Итак, требования к машине для запуска CMF немного нестандартные, хотя никакого криминала.

Во-первых, нужно удовлетворить стандартные потребности для Symfony 2 (весьма вероятно, что с этим уже все в порядке):

* установить PHP 5.3.3 или выше
* включить поддержку JSON
* включить поддержку ctype
* в ```php.ini``` корректно установить ```date.timezone```
* PDO для Doctrine

[Все остальное](http://symfony.com/doc/current/reference/requirements.html) (APC и так далее) — по желанию.

Далее идут требования Symfony CMF. По умолчанию для хранения данных используется SQLite, поэтому проверяем, чтобы было установлено расширение ```pdo_sqlite```.

Чтобы использовать другие бэкенды, устанавливаем:

* [Apache Jackrabbit](http://jackrabbit.apache.org/downloads.html) и соответственно Java.
* [Midgard2 PHPCR](http://midgard-project.org/phpcr/) и его расширение для PHP. К сожалению, пакетов для этого пока мало: они либо помечены, как нестабильные (я брал в sid в случае с Debian), либо собраны далеко не под все платформы, либо собраны, но для устаревших версий ОС. В целом, если поискать, можно найти и RPM, и deb-пакеты. На крайний случай расширение можно собрать из [исходников](https://github.com/midgardproject/midgard-php5).
